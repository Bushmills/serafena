# replacement for service switch, which delegates specifics to external "steckdose" script.
# service power integrates those specifics into the service.

# power on/off/toggle/state  addr MAC socket	# device on socket at addr MAC on/off/toggle/state
# power on/off/toggle/state  name devicename	# device with name on/off/toggle/state
# power on/off/toggle/state  socket n		# device on socket on power strip connected to localhost on/off/toggle/state
# power name MAC socket name			# give a name to device plugged into MAC socket
# power name MAC socket				# query name of device at MAC socket
# power where name				# query MAC socket of device name
# power mac					# produce power strip MAC(s)

# -------------------------------------------------------------------------------------------------------------------------------
#  handle
# -------------------------------------------------------------------------------------------------------------------------------

declare -A option				# translate commands to sispmctl options. This hash
option[on]="o"					# is also used to check whether cmd is one of on/off/toggle/state,
option[off]="f"					# or another command which doesn't map well into this command/mode matrix.
option[toggle]="t"
option[state]="ng"

socketnames="$tmp/socketnames"
mkdir -p "$socketnames"

# careful: $1 contains a space. use quotes!
addr2name()  { [[ -h "$socketnames/$1" ]] && readlink "$socketnames/$1"; }	# return name associated with $mac $socket, or void if none
name2addr()  { [[ -h "$socketnames/$1" ]] && readlink "$socketnames/$1"; }	# return $mac $socket associated with name, or void if none

power_switch_addr()  {
   cmd="$1"							# on/off/toggle/state
   mac="$2"
   socket="$3"							# 1..4
   serial="$(sispmctl -s | sed -n 's/^serial number: *//p')"	# @TODO verify that power strip is still connected, issue a database update if it isn't
   if [[ $mac == $serial ]]; then					# power strip connected to this computer
      if [[ "$cmd" == "state" ]]; then
         sispmctl -q -D $mac -ng $socket 2> /dev/null			# query socket power state
      else
         sispmctl -q -D $mac -${option[$1]} $socket 2> /dev/null	# on, off, toggle. 
         name="$(addr2name "$mac $socket")"				# void if no name assigned.
         : ${name:="$mac.$socket"}					# in that case, $serial:$socket will be used as name.
         state=$(sispmctl -q -D $mac -ng $socket 2> /dev/null)		# query socket power state
         signal @event socket $mac $socket $name $state			# signal socket event to all event group members
      fi
   else
      signal @power_$mac power $cmd addr $mac $socket			# power strip is somewhere else
   fi
}




power_switch_name()  {
   addr="$(name2addr $2)"					# retrieve mac, socket of $2
   [[ -z "$addr" ]] ||
   power_switch_addr "$1" $addr					# don't quote $addr - those are 2 arguments:  $mac $socket 
}


# using circular symlinks as "database" - name to addr, and addr to name.
# some programs, notably fsck, may not like those.
# I may change those, as I'm not entirely happy with this "database" format.
power_admin_name()  {
   serial="$1"
   socket="$2"
   name="$3"
   addr="$serial $socket"
   if [[ -z "$name" ]]; then
      addr2name "$addr"
   else
      [[ -h "$socketnames/$addr" ]] && {
         oldname=$(readlink "$socketnames/$addr")
         [[ -h "$socketnames/$oldname" ]] &&
         rm "$socketnames/$oldname"
      }
      ln -sf "$addr" "$socketnames/$name"
      ln -sf "$name" "$socketnames/$addr"			# associating $name with $mac $socket
   fi
}

power_admin_where()  {
   cd $socketnames
   names="${@:-[a-z]*}"
   for name in $names; do
      [[ -h "$name" ]] && {
         read mac socket <<< $(readlink "$name")
         h=$(members "power_$mac")
         echo "$mac $socket $h $name"
      }
   done | sort
}

power_admin_mac()  {
   sispmctl -s |
   awk -v hostname=$HOSTNAME ' $1$2 == "serialnumber:" { print $3, hostname }'
}

power_admin_host()  {
   sispmctl -s |
   awk -v hostname=$HOSTNAME ' $1$2 == "serialnumber:" { print hostname, $3 }'
}

# -------------------------------------------------------------------------------------------------------------------------------
#  dispatch
# -------------------------------------------------------------------------------------------------------------------------------

cmd="$1"					# on, off, toggle, state, name
shift
if [[ -z ${option[$cmd]} ]]; then		# name, unknown
   type -t power_admin_$cmd > /dev/null &&
   power_admin_$cmd $@
else						# on, off, toggle, state
   mode="$1"					# addr, name, socket
   shift
   power_switch_${mode} $cmd $@			# (addr:) cmd mac socket / (name) $cmd name / (socket) $cmd socket
fi
true

# -------------------------------------------------------------------------------------------------------------------------------
