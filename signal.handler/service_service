# disable or enable service, cat, install, uninstall

# @HELP signal host service list
# @HELP signal host service list name [name [name [...]]]
# @HELP signal host service state
# @HELP signal host service state name [name [name [...]]]
# @HELP signal host service stamp
# @HELP signal host service stamp name [name [name [...]]]
# @HELP signal host service provider
# @HELP signal host service provider name [name [name [...]]]
# @HELP signal host service cat name [name [name [...]]]
# @HELP signal host service enable name [name [name [...]]]
# @HELP signal host service disable name [name [name [...]]]
# @HELP signal host service uninstall name [name [name [...]]]
# @HELP signal host service install name [name [name [...]]]
# @HELP list, state and stamp are similar, but differing in displayed column order
# @HELP this is meant to ease parsing the output. general rule is:
# @HELP the column giving the subcommand its is first. hostname is third. rest fall into place.


# @TODO update service broker

service_enable()  {
   [[ -f $f ]] || error "can't $cmd $service"
   chmod +x $f 
}

service_disable()  {
   [[ -f $f ]] || error "can't $cmd $service"
      chmod -x $f 
}

service_cat()  {
   [[ -f $f ]] || fatal "can't $cmd $service"
   cat $f
}

service_uninstall()  {
   [[ -f $f ]] || fatal "can't $cmd $service"
   rm -f $f
}

service_install()  {
# install new service from pool
   if [[ -f $f ]]; then
      error "service $service already installed"
   else
      signal @pool pool |
      grep "^$service " |
      while read service stamp description; do
         signal @pool pool cat $service > $f
         touch -d @$stamp $f
      done
   fi
}

service_state()  {
   [[ -f $f ]] && {
      stamp="$(stat -c%Y $f)"
      [[ -x $f ]]		     # state
      printf '%d %-14s %-10s %d\n'  "$(($?^1))" "$service" "$HOSTNAME" "$stamp"  
   }
   return 0
}

service_provider()  {
   [[ -f $f ]] && {
      stamp="$(stat -c%Y $f)"
      [[ -x $f ]]		     # state
      printf '%-10s %d %-14s %d\n'  "$HOSTNAME" "$(($?^1))" "$service" "$stamp"  
   }
   return 0
}

service_stamp()  {
   [[ -f $f ]] && {
      stamp="$(stat -c%Y $f)"
      [[ -x $f ]]						     # state
      printf '%d %-14s %-10s %d\n'  "$stamp" "$service" "$HOSTNAME" "$(($?^1))"
   }
   return 0
}

service_list()  {
   [[ -f $f ]] && {
      read description < $f
      description="${description#\#}"
      stamp="$(stat -c%Y $f)"
      [[ -x $f ]]							 # state
      printf '%-14s %d %-10s %d %s\n'  "$service" "$stamp" "$HOSTNAME" "$(($?^1))" "${description## }"
   }
   return 0
}

# this can be speeded up - look at service_pool:
# don't call stat in subcommand handlers for each file.
# instead, let it produce the loop parameters once, outside the loop.
cmd=$1
shift
type -t service_$cmd > /dev/null || fatal "can't $cmd $service"         # no such subcommand
declare -A installed							# indicator which commands will loop through installed if args void
installed[list]=1							#    makes most sense 
installed[state]=1							#    with these three
installed[stamp]=1							#
installed[provider]=1							#
[[ -z $1 ]] &&								# no service, or list of, specified
((installed[$cmd])) &&							# and command makes sense with looping through local services
files=($p/service_*)							# populate files array with local services
for service in ${@:-${files[@]##$p/service_}}; do			# produce list of locally installed services instead, to loop through
   f="$p/service_$service"						# handler -> /path/to/service_handler
   service_$cmd								# dispatch to subcommand
done
