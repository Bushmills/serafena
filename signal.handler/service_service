# disable or enable service, cat, install, uninstall

# @HELP signal host service list
# @HELP signal host service list name [name [name [...]]]
# @HELP signal host service state
# @HELP signal host service state name [name [name [...]]]
# @HELP signal host service cat name [name [name [...]]]
# @HELP signal host service enable name [name [name [...]]]
# @HELP signal host service disable name [name [name [...]]]
# @HELP signal host service uninstall name [name [name [...]]]
# @HELP signal host service install name [name [name [...]]]

# consider to add:
# signal host service              # replacement for signal host services
# signal host service info name    # replacement for signal host services name 


# @TODO update service broker

service_enable()  {
   [[ -f $f ]] || error "can't $cmd $service"
   chmod +x $f 
}

service_disable()  {
   [[ -f $f ]] || error "can't $cmd $service"
      chmod -x $f 
}

service_state()  {
   [[ -f $f ]] && {
      [[ -x $f ]]
      echo "$(($?^1)) $service"
   }
   return 0
}

service_cat()  {
   [[ -f $f ]] || fatal "can't $cmd $service"
   cat $f
}

service_uninstall()  {
   [[ -f $f ]] || fatal "can't $cmd $service"
   rm -f $f
}

service_install()  {
# install new service from pool
   if [[ -f $f ]]; then
      error "service $service already installed"
   else
      [[ -z $pool ]] && source $fragments/pool
      signal $pool pool |
      grep "^$service " |
      while read service stamp description; do
         signal $pool pool cat $service > $f
         touch -d @$stamp $f
      done
   fi
}

service_list()  {
   [[ -f $f ]] && {
      [[ -x $f ]]
      state="$(($?^1))"
      read description < $f
      description="${description#*#}"
      stamp="$(stat -c%Y $f)"
      printf '%d %-14s %-10s %-3s %s\n'  "$stamp" "$service" "$HOSTNAME" "$state" "${description## }"
   }
   return 0
}

cmd=$1
shift
type -t service_$cmd > /dev/null || fatal "can't $cmd $service"         # no such subcommand
declare -A installed							# indicator which commands will loop through installed if args void
installed[list]=1							#    makes most sense 
installed[state]=1							#    with these two
[[ -z $1 ]] &&								# no service, or list of, specified
((installed[$cmd])) &&							# and command makes sense with looping through local services
files=($p/service_*)							# populate files array with local services
for service in ${@:-${files[@]##$p/service_}}; do			# produce list of locally installed services instead, to loop through
   f="$p/service_$service"						# handler -> /path/to/service_handler
   service_$cmd								# dispatch to subcommand
done
