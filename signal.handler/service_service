# disable or enable service, cat, install, uninstall

# @HELP signal host service list
# @HELP signal host service list name [name [name [...]]]
# @HELP signal host service state
# @HELP signal host service state name [name [name [...]]]
# @HELP signal host service stamp
# @HELP signal host service stamp name [name [name [...]]]
# @HELP signal host service provider
# @HELP signal host service provider name [name [name [...]]]
# @HELP signal host service cat name [name [name [...]]]
# @HELP signal host service enable name [name [name [...]]]
# @HELP signal host service disable name [name [name [...]]]
# @HELP signal host service uninstall name [name [name [...]]]
# @HELP signal host service install name [name [name [...]]]
# @HELP list, state and stamp are similar, but differing in displayed column order
# @HELP this is meant to ease parsing the output. general rule is:
# @HELP the column giving the subcommand its is first. hostname is third. rest fall into place.


# @TODO update service broker

service_enable()  {
   [[ -f $f ]] || error "can't $cmd $service"
   chmod +x $f 
}

service_disable()  {
   [[ -f $f ]] || error "can't $cmd $service"
      chmod -x $f 
}

service_cat()  {
   [[ -f $f ]] || fatal "can't $cmd $service"
   cat $f
}

service_uninstall()  {
   [[ -f $f ]] || error "can't $cmd $service"
   export p f cmd service
   bash <<< "$(sed -n 's/^# @UNINSTALL *//p' $f)"			# found @UNINSTALL uninstallation code: execute 
   facettes=$(sed -n 's/^# @FACETTE *//p' $f)				# found @FACETTE list of additional service names: remove facettes
   for facette in $facettes; do 
      [[ -h "${f%$service}$facette" ]] &&
      rm "${f%$service}$facette"
   done
   rm -f $f								# finally, remove service
}

service_install()  {
# install new service from pool
   [[ -f $f ]] && error "service $service already installed"
   found=$(signal @pool pool | grep "^$service ") || error "service $service not found on pool"
   echo -n "installing service: $service"
   read service stamp description <<< $found
   signal @pool pool cat $service > $f
   touch -d @$stamp $f
   export p f cmd service
   bash <<< "$(sed -n 's/^# @INSTALL *//p' $f)"				# found @INSTALL installation code: execute 
   facettes=$(sed -n 's/^# @FACETTE *//p' $f)				# found @FACETTE list of additional service names: symlink
   [[ -z $facettes ]] || echo -n ", with facettes:"
   for facette in $facettes; do 
      echo -n " $facette"
      ln -s ${f##*/} ${f%$service}$facette
   done
   echo
}

service_state()  {
   [[ -f $f ]] && {
      [[ -x $f ]]		     # state
      printf '%d %-14s %-10s %d'  "$(($?^1))" "$service" "$HOSTNAME" "$(stat -c%Y $f)"  
      echo
   }
   true
}

# @INFO doesn't show disabled services - idea is that an installed, but disabled service isn't really provided.
#       .pretend of group @servicebroker depends on this behaviour.
service_provider()  {
   [[ -x $f ]] && {
      printf '%-10s %-14s %d' "$HOSTNAME" "$service" "$(stat -c%Y $f)"  
      echo
   }
   true
}

service_stamp()  {
   [[ -f $f ]] && {
      [[ -x $f ]]		  # stamp				     # state
      printf '%d %-14s %-10s %d'  "$(stat -c%Y $f)" "$service" "$HOSTNAME" "$(($?^1))"
      echo
   }
   true
}

service_list()  {
   [[ -f $f ]] && {
      stamp="$(stat -c%Y $f)"
      [[ -h $f ]] && {
         description="$(readlink $f)" 
         description="-> ${description#*service_} $service"
      } || {
         read description < $f
         hash='#'		# workaround for \ vs \\ escape problem
         description="${description#$hash}"
         description="   ${description## }"
      }
      [[ -x $f ]]							 # state
      printf '%-14s %d %-10s %d %s'  "$service" "$stamp" "$HOSTNAME" "$(($?^1))" "$description"
      echo
   }
   true
}

service_short()  {
   [[ -f $f ]] &&
   [[ -x $f ]] &&
   echo "$service"
   return 0
}

# this can be speeded up - look at service_pool:
# don't call stat in subcommand handlers for each file.
# instead, let it produce the loop parameters once, outside the loop.
cmd="${1:-short}"							# default to "list" command if none specified
shift
type -t service_$cmd > /dev/null || fatal "can't $cmd $service"         # no such subcommand
[[ -z $1 ]] && {							# void args to command:
# @INFO an interesting way to determine whether a string completely matches any from a list of strings follows
   wild=(list state stamp provider short)				#    list of commands which wildcard void to *
   wild=(${#wild[@]} ${wild[@]#$cmd})					#    yes, a bit wild this is. It makes perfectly sense though
   ((wild == ${#wild[@]})) && files=($p/service_*)			# array gets populated from wildcarded file list if command matches any
}
for service in ${@:-${files[@]##$p/service_}}; do			# list of services, either by arg, or expanded by wildcard
   f="$p/service_$service"						# handler -> /path/to/service_handler
   service_$cmd								# dispatch to subcommand
done
