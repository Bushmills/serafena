# disable or enable service, cat, install, uninstall

# @HELP signal host service list
# @HELP signal host service list name [name [name [...]]]
# @HELP signal host service state
# @HELP signal host service state name [name [name [...]]]
# @HELP signal host service stamp
# @HELP signal host service stamp name [name [name [...]]]
# @HELP signal host service provider
# @HELP signal host service provider name [name [name [...]]]
# @HELP signal host service cat name [name [name [...]]]
# @HELP signal host service enable name [name [name [...]]]
# @HELP signal host service disable name [name [name [...]]]
# @HELP signal host service uninstall name [name [name [...]]]
# @HELP signal host service install name [name [name [...]]]
# @HELP list, state and stamp are similar, but differing in displayed column order
# @HELP this is meant to ease parsing the output. general rule is:
# @HELP the column giving the subcommand its is first. hostname is third. rest fall into place.


# @TODO update service broker

service_enable()  {
   [[ -f $f ]] || error "can't $cmd $service"
   chmod +x $f 
}

service_disable()  {
   [[ -f $f ]] || error "can't $cmd $service"
      chmod -x $f 
}

service_cat()  {
   [[ -f $f ]] || fatal "can't $cmd $service"
   cat $f
}

service_uninstall()  {
   [[ -f $f ]] || error "can't $cmd $service"
   export p f cmd service
   bash <<< "$(sed -n 's/^# @UNINSTALL *//p' $f)"			# found @UNINSTALL uninstallation code: execute 
   facettes=$(sed -n 's/^# @FACETTE *//p' $f)				# found @FACETTE list of additional service names: remove facettes
   for facette in $facettes; do 
      [[ -h "${f%$service}$facette" ]] &&
      rm "${f%$service}$facette"
   done
   rm -f $f								# finally, remove service
}

service_install()  {
# install new service from pool
   if [[ -f $f ]]; then
      error "service $service already installed"
   else
      signal @pool pool |
      grep "^$service " |
      while read service stamp description; do
         signal @pool pool cat $service > $f
         touch -d @$stamp $f
         export p f cmd service
         bash <<< "$(sed -n 's/^# @INSTALL *//p' $f)"				# found @INSTALL installation code: execute 
         facettes=$(sed -n 's/^# @FACETTE *//p' $f)				# found @FACETTE list of additional service names: symlink
         for facette in $facettes; do 
            ln -s ${f##*/} ${f%$service}$facette
         done
      done
   fi
}

service_state()  {
   [[ -f $f ]] && {
      stamp="$(stat -c%Y $f)"
      [[ -x $f ]]		     # state
      printf '%d %-14s %-10s %d'  "$(($?^1))" "$service" "$HOSTNAME" "$stamp"  
      echo
   }
   return 0
}

service_provider()  {
   [[ -f $f ]] && {
      stamp="$(stat -c%Y $f)"
      [[ -x $f ]]		     # state
      printf '%-10s %d %-14s %d'  "$HOSTNAME" "$(($?^1))" "$service" "$stamp"  
      echo
   }
   return 0
}

service_stamp()  {
   [[ -f $f ]] && {
      stamp="$(stat -c%Y $f)"
      [[ -x $f ]]						     # state
      printf '%d %-14s %-10s %d'  "$stamp" "$service" "$HOSTNAME" "$(($?^1))"
      echo
   }
   return 0
}

service_list()  {
   [[ -f $f ]] && {
      stamp="$(stat -c%Y $f)"
      [[ -h $f ]] && {
         description="$(readlink $f)" 
         description="-> facette of ${description#*service_}"
      } || {
         read description < $f
         description="${description#\#}"
      }
      [[ -x $f ]]							 # state
      printf '%-14s %d %-10s %d %s'  "$service" "$stamp" "$HOSTNAME" "$(($?^1))" "${description## }"
      echo 
  }
   return 0
}

service_short()  {
   [[ -f $f ]] &&
   [[ -x $f ]] &&
   echo "$service"
   return 0
}

# this can be speeded up - look at service_pool:
# don't call stat in subcommand handlers for each file.
# instead, let it produce the loop parameters once, outside the loop.
cmd="${1:-short}"							# default to "list" command if none specified
shift
type -t service_$cmd > /dev/null || fatal "can't $cmd $service"         # no such subcommand
[[ -z $1 ]] && {							# void args to command:
# @INFO an interesting way to determine whether a string completely matches any from a list of strings follows
   wild=(list state stamp provider short)				#    list of commands which wildcard void to *
   wild=(${#wild[@]} ${wild[@]#$cmd})					#    yes, a bit wild this is. It makes perfectly sense though
   ((wild == ${#wild[@]})) && files=($p/service_*)			# array gets populated from wildcarded file list if command matches any
}
for service in ${@:-${files[@]##$p/service_}}; do			# list of services, either by arg, or expanded by wildcard
   f="$p/service_$service"						# handler -> /path/to/service_handler
   service_$cmd								# dispatch to subcommand
done
