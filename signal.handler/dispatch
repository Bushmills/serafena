#!/bin/bash
# script called from xinetd, service "signal"
# -----------------------
# --- service dispatch ---
# -----------------------

# @TODO add initialisation function, executed on first run.
# For updating service broker when a host starts.
# Intercepting a shutdown event would be great too.

benchmark=0						# event recording to a file common with all hosts
timeout=5						# netcat wants reply within this number of seconds
logging=1

# "visual" errors and warnings add source of offending file to output, with the error line marked.
#warnings=0						# no warnings shown
warnings=1						# short warnings shown
#warnings=2						# visual warnings shown

#errors=0                                               # short report of fatal errors only
#errors=1                                               # short report of all error
errors=2                                                # short report of non-fatal errors, visual report of fatal errors
#errors=3                                               # visual report of all errors

# the above variables can be superseded by variables set with:
#    signal host variable name = value
# to turn logging off on all hosts, use:
#    signal all variable logging = 0


#tmp="/tmp/serafena"
tmp="/usr/local/lib/serafena"
mkdir -p "$tmp"
vars="$tmp/vars"
[[ -f $vars ]] && source $vars
groups="$tmp/groups"

# the initialisation action for groups could be majority vote:
# signal @all group | sort | uniq -c | sort -n | while read count group; do echo $group; done ...

#port=2226321649126  # hm :)   that number printed in radix 36 shows as "serafena". a bit large.
#port=51976          # same number modulo 2^16       
#port=5384           # alternative, could read. with much imagination, as SERA
port=10000						# port serafena listens to
p="/etc/xinetd.d/signal.handler"			# base directory of serafena file
fragments="$p/fragments"				# deduplicated code fragments
logname="service request"				# leading text of log entries
read -rst1 service remainder
f="$p/service_$service"					# name of service handler file
benchfile="/misc/common/serafena.benchmark"


warning()  { ((warnings)) &&
   source $fragments/notice "WARNING" "$((warnings == 2))" "${BASH_SOURCE[1]}" "$BASH_LINENO" "$@"
}

# making all errors abortive now - with output over the net, there is no dedicated error output handle now.
# message of non-abortive errors could be found in redirected output, which wasn't quite the intention.
error()  {   ((errors)) &&
   source $fragments/notice "ERROR"   "$((errors == 3))"   "${BASH_SOURCE[1]}" "$BASH_LINENO" "$@"
   exit 1
}

fatal()  {
   source $fragments/notice "FATAL"   "$((errors == 2))"   "${BASH_SOURCE[1]}" "$BASH_LINENO" "$@"
   exit 2
}

# group -> list of hosts. also expand pretend groups.
members()  {
   group="$groups/$1"
   [[ -d $group ]] || fatal "no such group $1"
   members=($group/*)
   [[ -f $members ]] &&
   echo "${members[@]#$group/}" || {
      [[ -f $group/.pretend ]] &&
      source $group/.pretend
   }
}


signal()  {
   ((benchmark)) && source $fragments/bench "signal $@"   
   hosts="$1"
   shift
   args="$@"
   [[ "${hosts:0:1}" == "@" ]] && hosts="$(members ${hosts:1})"
   for host in $hosts; do
      {  nc -w $timeout $host $port <<< "$args" ||
         fatal "$host took too long to reply to host $HOSTNAME request of $service $args"
      } &
   done
   wait
}

sl()  { signal localhost $@; }

# $p $service $f
#sl()  {
#   source $f $@
#}

((logging)) && {
   logmessage="$logname received: ${service}"
   [[ -z $remainder ]] || logmessage+=" $remainder"
   logger "$logmessage"
}

if [[ -x $f ]]; then
   logmessage="$logname answered: ${service}"				# must precede source, because $service may be reused
   source $f $remainder							# execute service handler
   ret=$?
   ((ret)) && {								# any variable could be changed by sourcing the service handler 
      logmessage+=": error $ret not dealt with by service handler"	# therefore may service handlers also set logmessage to their liking
      error "$logmessage"
   }
else
   logmessage="$logname ignored: no handler for service ${service}"
   error "$logmessage"
fi

((logging)) && logger "$logmessage"
