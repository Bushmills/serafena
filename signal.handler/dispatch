#!/bin/bash
# script called from xinetd, service "signal"
# -----------------------
# --- service dispatch ---
# -----------------------

# @TODO add initialisation function, executed on first run.
# For updating service broker when a host starts.
# Intercepting a shutdown event would be great too.

benchmark=0						# event recording to a file common with all hosts
timeout=10						# netcat wants reply within this number of seconds
logging=1

# "visual" errors and warnings add source of offending file to output, with the error line marked.
#warnings=0						# no warnings shown
warnings=1						# short warnings shown
#warnings=2						# visual warnings shown

#errors=0                                               # short report of fatal errors only
#errors=1                                               # short report of all error
errors=2                                                # short report of non-fatal errors, visual report of fatal errors
#errors=3                                               # visual report of all errors

# the above variables can be superseded by variables set with:
#    signal host variable name = value
# to turn logging off on all hosts, use:
#    signal all variable logging = 0


#tmp="/tmp/serafena"
tmp="/usr/local/lib/serafena"
mkdir -p "$tmp"
vars="$tmp/vars"
[[ -f $vars ]] && source $vars
groups="$tmp/groups"

# hardcoding initial list of hosts now, as currently no initialisation action to populate that list exists. 
[[ -f $groups ]] && source $groups
[[ -z $all ]] && echo 'all="odroid cubie radxa raspberry buffalo"' >> $groups

# the initialisation action for groups could be majority vote:
# signal @all group | sort | uniq -c | sort -n | while read count group; do echo $group; done ...

port=10000						# port serafena listens to
p="/etc/xinetd.d/signal.handler"			# base directory of serafena file
fragments="$p/fragments"				# deduplicated code fragments
logname="service request"				# leading text of log entries
read -rst1 service remainder
f="$p/service_$service"					# name of service handler file
benchfile="/misc/common/serafena.benchmark"


warning()  { ((warnings)) &&
   source $fragments/notice "WARNING" "$((warnings == 2))" "${BASH_SOURCE[1]}" "$BASH_LINENO" "$@"
}

error()  {   ((errors)) &&
   source $fragments/notice "ERROR" "$((errors == 3))" "${BASH_SOURCE[1]}" "$BASH_LINENO" "$@"
}

fatal()  {
   source $fragments/notice "FATAL" "$((errors == 2))" "${BASH_SOURCE[1]}" "$BASH_LINENO" "$@"
   exit 1
}

signal()  {
   ((benchmark)) && source $fragments/bench "signal $@"   
   hosts="$1"
   shift
   args="$@"
   [[ $hosts == @* ]] && {
      source $groups
      hosts="${hosts:1}" 
      hosts="${!hosts}"
   }
   for host in $hosts; do
      {  nc -w $timeout $host $port <<< "$args" ||
         fatal "$host took too long to reply to host $HOSTNAME request of $service $args"
      } &
   done
   wait
}

((logging)) && {
   logmessage="$logname received: ${service}"
   [[ -z $remainder ]] || logmessage+=" $remainder"
   logger "$logmessage"
}

if [[ -x $f ]]; then
   logmessage="$logname answered: ${service}"				# must precede source, because $service may be reused
   source $f $remainder							# execute service handler
   ret=$?
   ((ret)) && {								# any variable could be changed by sourcing the service handler 
      logmessage+=": error $ret not dealt with by service handler"	# therefore may service handlers also set logmessage to their liking
      error "$logmessage"
   }
else
   logmessage="$logname ignored: no handler for service ${service}"
   error "$logmessage"
fi

((logging)) && logger "$logmessage"
