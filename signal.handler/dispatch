#!/bin/bash
# script called from xinetd, service "signal"
# -----------------------
# --- service dispatch ---
# -----------------------


# -------------------------------------------------------------------------------------------------------------------------------------------------------

benchmark=0						# event recording to a file common with all hosts
timeout=5						# netcat wants reply within this number of seconds
logging=1
raw=0

# "visual" errors and warnings add source of offending file to output, with the error line marked.
#warnings=0						# no warnings shown
warnings=1						# short warnings shown
#warnings=2						# visual warnings shown

#errors=0                                               # short report of fatal errors only
#errors=1                                               # short report of all error
errors=2                                                # short report of non-fatal errors, visual report of fatal errors
#errors=3                                               # visual report of all errors

# the above variables can be superseded by variables set with:
#    signal host variable name = value
# to turn logging off on all hosts, use:
#    signal all variable logging = 0

std=1
err=2
outputcontrol="@@@serafena_output_control@@@"

[[ -f /etc/serafena.conf ]] &&
source /etc/serafena.conf

# set reasonable defaults for the variables expected to be set in serafena.conf
: ${tmp:="/usr/local/lib/serafena"}
: ${vars:="$tmp/vars"}    
[[ -f $vars ]] && source $vars
: ${groups:="$tmp/groups"}
: ${inventory:="$tmp/inventory"}
: ${requestcounters:=$tmp/requests}

mkdir -p "$tmp"         # move to first actual potential use
mkdir -p "$inventory"
mkdir -p "$requestcounters"

#port=2226321649126  # hm :)   that number printed in radix 36 shows as "serafena". a bit large.
#port=51976          # same number modulo 2^16       
#port=5384           # alternative, could read. with much imagination, as SERA
myself="$HOSTNAME"
port=10000						# port serafena listens to
p="/etc/xinetd.d/signal.handler"			# base directory of serafena file
fragments="$p/fragments"				# deduplicated code fragments
logname="service request"				# leading text of log entries
benchfile="/misc/common/serafena.benchmark"
auth="$HOSTNAME"					# dummy authentication token for sending requests


# -------------------------------------------------------------------------------------------------------------------------------------------------------


warning()  { ((warnings)) &&
   source $fragments/notice "WARNING" "$((warnings == 2))" "${BASH_SOURCE[1]}" "$BASH_LINENO" "$@"
}

# making all errors abortive now - with output over the net, there is no dedicated error output handle now.
# message of non-abortive errors could be found in redirected output, which wasn't quite the intention.
error()  {   ((errors)) &&
   source $fragments/notice "ERROR"   "$((errors == 3))"   "${BASH_SOURCE[1]}" "$BASH_LINENO" "$@"
   exit 1
}

fatal()  {
   source $fragments/notice "FATAL"   "$((errors == 2))"   "${BASH_SOURCE[1]}" "$BASH_LINENO" "$@"
   exit 2
}

# I don't like the the following functions are loaded everytime, while there are only few
# places where they are actially used. Loading by sourcing on a per-need base may be preferable.
# group -> list of hosts. also expand pretend groups.
members()  {
   group="$groups/$1"
   [[ -d $group ]] || fatal "no such group $1"
   members=($group/*)
   [[ -f $members ]] &&
   echo "${members[@]#$group/}" || {
      [[ -f $group/.pretend ]] &&
      source $group/.pretend
   }
}


attr="\x1b["
normal="${attr}0m"
# output goes through this functions, which strips the meta part.
printline()  {
   line="$1"						# $1 is whole line, including spaces
   ((raw)) || {
      [[ "${line%% *}" == "$outputcontrol" ]] && {	# line contains meta
         line="${line#* }"				# strip meta header
         metas="${line%% *}"				# extract meta
         line="${line#* }"				# strip meta
         local IFS=:
         metas=($metas)					# split meta
         for nextmeta in ${metas[@]}; do
            meta[${nextmeta%%=*}]="${nextmeta#*=}"	# assign meta variables to corresponding array elements
         done
      }
   }
   [[ -z "${meta[0]}" ]]  &&
   printf '%s\n' "$line" || 				# don't factor. print one complete line with one single printf statement.
   printf "${attr}$(((meta[2]==0)+35))m%-10s$normal %s\n" "${meta[0]}:" "$line"
}

inc()  {
   [[ -f $1 ]] &&
   read n < $1
   echo $((n+1)) > $1
}

signal()  {
   ((benchmark)) && source $fragments/bench "signal $@"   
   hosts="$1"
#   [[ -z $hosts ]] &&
#      members all || { 
      shift
      args="$@"
      [[ "${hosts:0:1}" == "@" ]] && hosts="$(members ${hosts:1})"
      for host in $hosts; do
         { 
            { nc $ncoptions -w $timeout $host $port <<< "$auth $args" ||
               fatal "$host took too long to reply to host $HOSTNAME request of $service $args" 
            } |
            while read line; do
               printline "$line"   #  > /proc/self/fd/2
            done
            # inc $requestcounters/requested
         } &
      done
      wait 2> /dev/null							# jobs may be finished already. quite possible if only one host was signalled to.
#   }
}

sl()  { signal localhost $@; }
sa()  { signal @all $@; }


# -------------------------------------------------------------------------------------------------------------------------------------------------------


read -rst1 auth service remainder					# read args passed along with service request
requesting="${auth%%:*}"						# name of host which requested the service
: ${service:=service}							# default to service service if no service given, because service has facettes to show service lists
f="$p/service_$service"							# service -> file name of handler
((logging)) && {
   logmessage="$logname received from $requesting: $service $remainder"
   logger "$logmessage"
   logmessage="$logname answered  to  $requesting: $service $remainder"	# must precede source, because $service may be reused
}
if [[ -x $f ]]; then							# executable service handler?
# @TODO authenticate request
#   inc $requestcounters/$requesting
   source $f $remainder
   ret="$?"
   ((logging)) && {
      ((ret)) && logmessage+=", error $ret returned"
      logger "$logmessage"
   }
   exit $ret
fi
logmessage="$logname ignored: no active handler for service $service"
((logging)) && logger "$logmessage"
error "$logmessage"
