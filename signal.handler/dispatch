#!/bin/bash
# script called from xinetd, service "signal"
# -----------------------
# --- service dispatch ---
# -----------------------

# @TODO add initialisation function, executed on first run.
# For updating service broker when a host starts.
# Intercepting a shutdown event would be great too.

benchmark=0						# event recording to a file common with all hosts
timeout=5						# netcat wants reply within this number of seconds
logging=1
raw=0

# "visual" errors and warnings add source of offending file to output, with the error line marked.
#warnings=0						# no warnings shown
warnings=1						# short warnings shown
#warnings=2						# visual warnings shown

#errors=0                                               # short report of fatal errors only
#errors=1                                               # short report of all error
errors=2                                                # short report of non-fatal errors, visual report of fatal errors
#errors=3                                               # visual report of all errors

# the above variables can be superseded by variables set with:
#    signal host variable name = value
# to turn logging off on all hosts, use:
#    signal all variable logging = 0

std=1
err=2
outputcontrol="@@@serafena_output_control@@@"

[[ -f /etc/serafena.conf ]] &&
source /etc/serafena.conf

# set reasonable defaults for the variables expected to be set in serafena.conf
: ${tmp:="/usr/local/lib/serafena"}
: ${vars="$tmp/vars"}    
[[ -f $vars ]] && source $vars
: ${groups="$tmp/groups"}
: ${inventory="$tmp/inventory"}

mkdir -p "$tmp"         # move to first actual potential use
mkdir -p "$inventory"   # move to first actual potential use

#port=2226321649126  # hm :)   that number printed in radix 36 shows as "serafena". a bit large.
#port=51976          # same number modulo 2^16       
#port=5384           # alternative, could read. with much imagination, as SERA
myself="$HOSTNAME"
port=10000						# port serafena listens to
p="/etc/xinetd.d/signal.handler"			# base directory of serafena file
fragments="$p/fragments"				# deduplicated code fragments
logname="service request"				# leading text of log entries
read -rst1 service remainder
: ${service:=service}					# default to service service is no service given. without args to service, it defaults to service list
f="$p/service_$service"					# name of service handler file
benchfile="/misc/common/serafena.benchmark"

warning()  { ((warnings)) &&
   source $fragments/notice "WARNING" "$((warnings == 2))" "${BASH_SOURCE[1]}" "$BASH_LINENO" "$@"
}

# making all errors abortive now - with output over the net, there is no dedicated error output handle now.
# message of non-abortive errors could be found in redirected output, which wasn't quite the intention.
error()  {   ((errors)) &&
   source $fragments/notice "ERROR"   "$((errors == 3))"   "${BASH_SOURCE[1]}" "$BASH_LINENO" "$@"
   exit 1
}

fatal()  {
   source $fragments/notice "FATAL"   "$((errors == 2))"   "${BASH_SOURCE[1]}" "$BASH_LINENO" "$@"
   exit 2
}

# I don't like the the following functions are loaded everytime, while there are only few
# places where they are actially used. Loading by sourcing on a per-need base may be preferable.
# group -> list of hosts. also expand pretend groups.
members()  {
   group="$groups/$1"
   [[ -d $group ]] || fatal "no such group $1"
   members=($group/*)
   [[ -f $members ]] &&
   echo "${members[@]#$group/}" || {
      [[ -f $group/.pretend ]] &&
      source $group/.pretend
   }
}

# output goes through this functions, which strips the meta part.
printline()  {
   line="$1"						# $1 is whole line, including spaces
   ((raw)) || {
      [[ "${line%% *}" == "$outputcontrol" ]] && {
         line="${line#* }"
         metas="${line%% *}"
         local IFS=:
         metas=($metas)
         for nextmeta in ${metas[@]}; do
            meta[${nextmeta%%=*}]="${nextmeta#*=}"
         done
         line="${line#* }"
      }
   }

# on lines with meta, passed element is assigned to corresponding element in array meta
   [[ -z "${meta[0]}" ]]  &&
      printf '%s\n' "$line" || 						# don't factor. print one complete line with one single printf statement.
      printf '(%s:%d) %s\n' "${meta[0]}" "${meta[2]:-0}" "$line"	# or parts of lines may have parts of lines from other hosts in between.

#   [[ -z "${meta[0]}" ]] || printf '(%s) ' "${meta[0]}" >&2
#   handle=(/dev/stdin /dev/stdout /dev/stderr)
#   out="${handle[${meta[1]:-1}]}"
#   printf '%s\n' "$line" >> $out
}

signal()  {
   ((benchmark)) && source $fragments/bench "signal $@"   
   hosts="$1"
   shift
   args="$@"
   [[ "${hosts:0:1}" == "@" ]] && hosts="$(members ${hosts:1})"
   for host in $hosts; do
      { 
         { nc -w $timeout $host $port <<< "$args" ||
            fatal "$host took too long to reply to host $HOSTNAME request of $service $args" 
         } |
         while read line; do
            printline "$line"
         done
      } &
   done
   wait %% 2> /dev/null                              # jobs may be finished already. quite possible if only one host was signalled to.
}

sl()  { signal localhost $@; }
sa()  { signal @all $@; }


((logging)) && {
   logmessage="$logname received: ${service}"
   [[ -z $remainder ]] || logmessage+=" $remainder"
   logger "$logmessage"
}

if [[ -x $f ]]; then
   logmessage="$logname answered: ${service}"				# must precede source, because $service may be reused
   source $f $remainder							# execute service handler
   ret=$?
   ((ret)) &&								# any variable could be changed by sourcing the service handler 
   logmessage+=", error $ret returned"					# therefore may service handlers also set logmessage to their liking
   ((logging)) && logger "$logmessage"
#   error "$logmessage"
   exit $ret
fi
logmessage="$logname ignored: no handler for service ${service}"
((logging)) && logger "$logmessage"
error "$logmessage"
