#!/bin/bash
# script called from xinetd, service "signal"
# -----------------------
# --- service dispatch ---
# -----------------------


# -------------------------------------------------------------------------------------------------------------------------------------------------------

benchmark=0						# event recording to a file common with all hosts
timeout=5						# netcat wants reply within this number of seconds
logging=1
raw=0

# "visual" errors and warnings add source of offending file to output, with the error line marked.
#warnings=0						# no warnings shown
warnings=1						# short warnings shown
#warnings=2						# visual warnings shown

#errors=0                                               # short report of fatal errors only
#errors=1                                               # short report of all error
errors=2                                                # short report of non-fatal errors, visual report of fatal errors
#errors=3                                               # visual report of all errors

# the above variables can be superseded by variables set with:
#    signal host variable name = value
# to turn logging off on all hosts, use:
#    signal all variable logging = 0

std=1
err=2
outputcontrol="@@@serafena_output_control@@@"

[[ -f /etc/serafena.conf ]] &&
source /etc/serafena.conf

# set reasonable defaults for the variables expected to be set in serafena.conf
: ${tmp:="/usr/local/lib/serafena"}
mkdir -p "$tmp"
: ${vars:="$tmp/vars"}    
[[ -f $vars ]] && source $vars
: ${groups:="$tmp/groups"}
: ${requestcounters:=$tmp/requests}


# @TODO inventory applies only to service brokers - stupid to let all hosts have that dir and overhead
: ${inventory:="$tmp/inventory"}
mkdir -p "$inventory"

# to enable request counter, for request authentication, execute this once:
#  mkdir -p "$requestcounters"  # consider chown root:serafena, and chmod g+w, 
#  chown root:serafena $requestcounters
#  chmod 770 $requestcounters   # or 775
# currently, users allowed to access request counters are members of group "staff", and request counter directory set accordingly.


#port=2226321649126  # hm :)   that number printed in radix 36 shows as "serafena". a bit large.
#port=51976          # same number modulo 2^16       
#port=5384           # alternative, could read. with much imagination, as SERA
port=10000								# port serafena listens to
p="/etc/xinetd.d/signal.handler"					# base directory of serafena file
fragments="$p/fragments"						# deduplicated code fragments
logname="serafena"							# leading text of log entries

# -------------------------------------------------------------------------------------------------------------------------------------------------------

type -t logger > /dev/null ||
logger()  {
   echo $@ >> /tmp/serafena.log
}

attr="\x1b["
normal="${attr}0m"
# output goes through this functions, which strips the meta part.
printline()  {
   line="$1"								# $1 is whole line, including spaces
   ((raw)) || {
      [[ "${line%% *}" == "$outputcontrol" ]] && {			# line contains meta
         line="${line#* }"						# strip meta header
         metas="${line%% *}"						# extract meta
         line="${line#* }"						# strip meta
         local IFS=:
         metas=($metas)							# split meta
         for nextmeta in ${metas[@]}; do
            meta[${nextmeta%%=*}]="${nextmeta#*=}"			# assign meta variables to corresponding array elements
         done
      }
   }
   [[ -z "${meta[0]}" ]]  &&
   printf '%s\n' "$line" || {						# don't factor. print one complete line with one single printf statement.
      printf "${attr}$(((meta[2]==0)+35))m%-10s${normal} %s\n" "${meta[0]}" "$line"
#      printf "${attr}$(((meta[2]==0)+35))m%-10s$normal %s\n" "${meta[0]}:" "$line"

#      ((meta[2])) && {
#         echo "error exit on printline with value ${meta[2]}"
#         exit ${meta[2]}			# as long as redirect to error out isn't done
# not a good idea, terminates  signal @all request  if one host can't provide. Too strict.
#      }
   }
}

inc()  {
   read n 2> /dev/null < $1 || {					# try to read counter from file
      touch $1								# read failed: create and initialise file
      chmod 666 $1 							# consider putting into serafena group, with g+w permissions
      n=0
   }
   echo $((n+1)) > $1
}

# $host   $@: service args
# signal to exactly one host
signal1()  {
   {  nc $ncoptions -w $timeout $host $port <<< "$HOSTNAME $@" ||
      source $fragments/error "$host took too long to reply to host $HOSTNAME request of $@" 
      [[ -w $requestcounters ]] && inc $requestcounters/$HOSTNAME.to.$host.$1   # ($1: service)
   } |
   while read -r line; do
      printline "$line"
   done

#   sed "s/^$outputcontrol [^ ]* //"	# remove meta completely for now because of a problem with this
					# implementation of printline when output contians escaped characters.
}

groupspecifier_0()  {							# single host of :group
   read -ra host <<< "$(source $fragments/members ${hosts:1})"		# read all hosts into an array
   host=${host[RANDOM % ${#host[@]}]}					# pick a random host
   signal1 $@
}

groupspecifier_1()  {							# all hosts of @group, backgrounded
   for host in $(source $fragments/members ${hosts:1}); do
      signal1 $@ &
   done
   wait 2> /dev/null							# jobs may be finished already. quite possible if only one host was signalled to.
}

groupspecifier_2()  {							# all hosts of %group, sequentially
   for host in $(source $fragments/members ${hosts:1}); do
      signal1 $@
   done
}

groupspecifier_3()  {							# all non-@%: hosts. i.e. non-groups. single hosts. presumably
   host="$hosts"
   signal1 $@
}

signal()  {
   hosts="$1"								# can be group or single host, therefore plural
   shift
   chars=":@%"
   index="${chars%${hosts:0:1}*}"
   groupspecifier_${#index} $@						# 0, 1, 2 for : @ %,  or 3 for other
}

sl()  { signal localhost $@; }
sa()  { signal @all $@; }

# -------------------------------------------------------------------------------------------------------------------------------------------------------

read -rst1 auth service remainder					# read args passed along with service request
requesting="${auth%%:*}"						# name of host which requested the service
: ${service:=service}							# default to service service if no service given, because service has facettes to show service lists
f="$p/service_$service"							# service -> file name of handler
requestid=$RANDOM
((logging)) &&
   logger "$logname request $requestid from $requesting: $service $remainder"
[[ -x $f ]] && {							# executable service handler?
# @TODO authenticate request
   [[ -w $requestcounters ]] &&
      inc $requestcounters/$requesting.to.$HOSTNAME.$service		# meant to go into request authentication hash
   [[ -r /etc/serafena.$service.conf ]] &&				# local config for requested service exists. read that too.
      source /etc/serafena.$service.conf 
   source $f $remainder							# read and execute service
   ret="$?"
   ((logging && ret)) && logger "$logname request $requestid returned $ret"
}
