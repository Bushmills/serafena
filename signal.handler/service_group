# named groups of hosts
# @HELP signal host group				# show all groups
# @HELP signal host group name				# show members of group name
# @HELP signal host group name =			# delete group
# @HELP signal host group name = host1 host2 host3 ...	# assign host1 host2 host3 to group name
# @HELP signal host group name += host1 host2 host3 ...	# add host1 host2 host3 to group name
# @HELP signal host group name -= host			# remove host from group. single host only

# keep groups harmonic over hosts, while storing them on each host:
# update -> publish

# one file per group may simplify updating group members.
# a combined version which can be source could be assembled when needed.
# useful when generating groups from different versions, intending to keep
# the version most widely used (voting), by simply overwriting the previous
# group file

# mostly a copy and paste job from service_variable. not happy but works for now.
# group += host was added.

group=$1
shift
touch $groups &&
if [[ -z "$group" ]]; then
   cat $groups						# signal host group
elif [[ -z $1 ]]; then					# signal host group foo
   source "$groups"
   echo "${!group}"
elif [[ $1 == "=" ]]; then				# signal host group foo =
   shift
   mv $groups $groups.old
   { sed "/^$group=/d" $groups.old
      [[ -z $1 ]] || echo "$group=\"$@\""		# signal host group foo = host
   } > $groups
elif [[ $1 == "+=" ]]; then				# signal host group foo +=
   shift
   [[ -z $1 ]] || {					# signal host group foo += host(s)
      source "$groups"
      mv $groups $groups.old
      { sed "/^$group=/d" $groups.old
        echo "$group=\"${!group} $@\""
      } > $groups
   } 
elif [[ $1 == "-=" ]]; then
   fatal "$1 not yet implemented"
else
   fatal "service group received wrong arguments"
fi
