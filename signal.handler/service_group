# named groups of hosts
# @HELP signal host group				# show members of all groups
# @HELP signal host group name				# show members of specified group 
# @HELP signal host group name =			# delete group
# @HELP signal host group name = host1 host2 host3 ...	# assign member(s) to group
# @HELP signal host group name + host1 host2 host3 ...	# add member(s) to group
# @HELP signal host group name - host1 host2 host3	# remove member(s) from group.
# @HELP signal host group name member host		# is host member of group?
# @HELP signal host group name from host		# read group from remote host, set local identically
# @HELP signal host group name to host			# copy local group to remote host
# @HELP signal host group name to @group		# copy local group to remote group
# @HELP signal host group name dead			# diagnostic on group members: report hosts which aren't responding to pings

# @TODO change subcommand dispatch away from that nested conditionals structure


listgroups()  {						# assumes that pwd is $groups. If not sure, cd $groups first
   for d in *; do   
      [[ -d $d ]] && rmdir --ignore-fail-on-non-empty $d
      [[ -d $d ]] && printf '%-20s %s' "$d" "$(members $d)"
      echo						# 
   done
}

group="${1//[!a-z0-9._-]/_}"				# rigorously substitute illegal chars against underscores
cmd="${2//[!a-z+=-]/_}"
shift 2
args=$(eval echo "$@")					# eval'ed for substitution and expansion
args="${args//[!a-z0-9 @._-]/_}"			# sanitising the expanded value
# @TODO some functions should throw an error if group is nonexistent or empty
mkdir -p $groups/$group &&
cd $groups/$group &&
if [[ -z "$group" ]];		then listgroups						# signal host group
elif [[ -z $cmd ]];		then members $group					# signal host group foo
elif [[ $cmd == "=" ]];		then rm -f *; [[ -z $args ]] || touch $args		# signal host group foo =
elif [[ $cmd == "+" ]];		then [[ -z $args ]]          || touch $args		# signal host group foo +
elif [[ $cmd == "-" ]];		then [[ -z $args ]]          || rm -f $args		# signal host group foo -
elif [[ $cmd == "member" ]];	then [[ ! -f $args ]]; echo $?				# signal host group name member name
# @TODO this membership test will fail with pretend groups and needs fixing
# @TODO organise functions such that those below require non-empty groups.
# @TODO as such, they need to query members. Because all following functions do,
# @TODO just calling member functions once here is enough for all functions.
elif [[ $cmd == from ]];        then [[ -z $args ]] || rm -f *; touch $(signal ${args%% *} group $group)
elif [[ $cmd == to ]];          then [[ -z $args ]] || signal ${args%% *} group $group = $(members $group)
elif [[ $cmd == dead ]];	then hosts=$(members $group)
                                     [[ -z $hosts ]] && fatal "no such group $group"
                                     fping -u -r1 $hosts 2>&1 | sed 's/ .*//'
else fatal "can't $group $cmd"
fi
true
