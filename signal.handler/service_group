# named groups of hosts
# @HELP signal host group				# show all groups
# @HELP signal host group name				# show members of group name
# @HELP signal host group name =			# delete group
# @HELP signal host group name = host1 host2 host3 ...	# assign host1 host2 host3 to group name
# @HELP signal host group name += host1 host2 host3 ...	# add host1 host2 host3 to group name
# @HELP signal host group name -= host1 host2 host3	# remove host from group. single host only
# @HELP signal host group name member host		# is host member of group?

# @TODO prevent multiple additions of same host to a group

# keep groups harmonic over hosts, while storing them on each host:
# update -> publish

# one file per group may simplify updating group members.
# a combined version which can be source could be assembled when needed.
# useful when generating groups from different versions, intending to keep
# the version most widely used (voting), by simply overwriting the previous
# group file

# mostly a copy and paste job from service_variable. not happy but works for now.
# group += host was added.

# @TODO change subcommand dispatch away from that nested conditionals structure



# each group one subdir
# each member a stub file
buildgroups()  {
   cd $base
   for d in *; do   
      rmdir --ignore-fail-on-non-empty $d
      [[ -d $d ]] && {
         members=($d/*)					# read list of group member
         [[ -f $members ]] &&
         echo "${d#*/}=\"${members[@]#$d/}\""		# output in form of  group="host1 host2 host3"
      }
   done
}

group=$1
shift
base=$groups.base
d="$base/$group"
mkdir -p $d &&
cd $d &&
if [[ -z "$group" ]]; then
   buildgroups						# signal host group
elif [[ -z $1 ]]; then					# signal host group foo
   members=(*)						# read list of group member
   [[ -f $members ]] &&
   echo *
elif [[ $1 == "=" ]]; then				# signal host group foo =
   shift
   rm -f *
   [[ ! -z $1 ]] &&
   touch $@
elif [[ $1 == "+=" ]]; then				# signal host group foo +=
   shift
   [[ ! -z $1 ]] &&					# signal host group foo += host(s)
   touch $@
elif [[ $1 == "-=" ]]; then
   shift
   [[ ! -z $1 ]] &&					# signal host group foo -= host
   rm -f $@
elif [[ $1 == "member" ]]; then				# signal host group name member name
   shift
   [[ ! -f $1 ]]
   echo $?
elif [[ $1 == dead ]]; then
   fping -u -r1 * 2>&1 | sed 's/ .*//'
elif [[ $1 == "test" ]]; then
   :
else
   fatal "service group received wrong arguments"
fi
buildgroups > $groups
