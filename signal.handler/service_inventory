# service broker multi-facette service handler: services inventory, provider, delegate
# inventory: build or selectively refresh service to host mapping database
# provider: who can respond to specified service requests
# delegate: forward a request to a machine able to respond

# @HELP signal @servicebroker inventory					# (re)build inventory of services on all hosts
# @HELP signal @servicebroker inventory <host1> <host2> ...		# add services of <host1|, <host2> ... to inventory
# @HELP signal @servicebroker delegate <service> <arguments>		# send request for <service> to a host which provides that service
# @HELP signal @servicebroker provider <service>			# list hosts providing <service>
# @HELP signal @servicebroker provider <service1> <service2> ...	# list hosts providing <service1>, <service2> ...
# @HELP signal @servicebroker connect <host>
# @HELP signal @servicebroker disconnect <host>
# @HELP signal @servicebroker testament
# @HELP signal @servicebroker testament host
# @HELP signal @servicebroker testament host commands ...


# problem with reconnecting hosts not reliably adding themselves to some groups.
# race condition dis- and reconnecting is suspected.
debug()  {
#   echo "$(date '+%F %T.%N') $@" >> /tmp/service.inventory.debug
   echo "$(date '+%F %T.%N') $@" |
   /usr/local/bin/mail l &
}

# doesnt remove services from unreachable hosts
broker_inventory()  {
   for host in ${@:-$(source $fragments/members all)}; do		# for each specified host (or @all, if void) ...
# @TODO - here is some potential to affect a wrong directory with deletion of files if host names are doctored accordingly,
      rm -f $inventory/*/$host						#    start by wiping info on host completely
# @TODO speedup potential: an additional service view, with just a horizontal list of active services, no extra info,
# @TODO can be used by touch in a single command. without a need to loop through the services.
      signal $host service state |
      while read state service host stamp _; do				#    then run through the list host reported as installed services
         ((state)) && {							#    only active services can be responded to
            mkdir -p $inventory/$service					#    host specific directory for tallying its services
            touch $inventory/$service/$host				#    mark service
         }
      done
   done
   rmdir --ignore-fail-on-non-empty $inventory/*
}

# @FACETTE provider
broker_provider()  {
   for service in $@; do						# for each specified host (or @all, if void) ...
      [[ -d $inventory/$service ]] && {
         cd $inventory/$service
         printf '%s ' $(ls -1 | sort -R)
      }
      echo
   done
}

# @FACETTE delegate
broker_delegate()  {
   service=$1
   shift
   cd $inventory/$service && {
      host=($(ls -1 | sort -R))
      signal $host $service $@
   }
}


# meant to receive information about connecting/disconnecting hosts from
# external sources, like hooks of vpn or dhcp servers.
# @TODO deal with case of multiple service brokers
# @FACETTE connect
broker_connect()  {
   h="$1"
debug "connecting $1"
   [[ -f $testaments/$h ]] || {			# allow new connect only if no testament of host exists on servicebroker
debug "$1 has no testament deposited"
      signal $h update && {			# more than in updating we're interested whether the host replies. Only then will it be added to @all
         sl inventory $h			# update service database
# -------------------------------------------------------------------------------------------------------------------------------------------------------
						# special case: if the host being added is the service broker itself, then host is not (yet) in group all
						# signalling to @all to add host won't add it to itself. 
         if [[ $h == $HOSTNAME ]]; then		# that condition is trapped and acted upon here
            sl group all + $h			# "it's me, make me member of @all too" 
            signal @others group all + $h	# tell others
						# @TODO host idea of @all may differ from others. may have to do things differently here. For example:
						# - why do we think that we are service broker? is that only a local notion, or do others agree?
						# - yes, service broker all right:
						# - ask @all for group all - that way it's very likely that at lease one live/up to date host replies
						# - add all obtained to local group @all
						# - remove dead hosts
						# - update local group all to @all
# -------------------------------------------------------------------------------------------------------------------------------------------------------
         else					# normal case: connecting host is not myself
debug "asked @all to add $h to @all"
            sa group all + $h			# add new host to group all of all
debug "asked $HOSTNAME to send @all to $h"
            sl group all to $h			# send @all to new host
         fi
debug "welcome signalled to $h"
         signal $h welcome			# host may wish to give some introductory statements
      }
   }
}



# @FACETTE disconnect
broker_disconnect()  {			# a disconnecting host gets removed in any case. Even if the host isn't known here at all,
   h="$1"
debug "disconnecting $h" 
   testament="$testaments/$h"
debug "asked @all to remove $h from @all"
   sa group all - $h			# attempt to remove a host which is not group member doesn't hurt
   [[ -f $testament ]] && {
debug "$h has testament deposited"
      mv $testament $testament.executed	# avoiding a race condition when 2nd disconnect is signaled before 1st has finished
      source $testament.executed
      rm $testament.executed
debug "testament of $h renamed, executed, removed"
   }
}

# @FACETTE testament
broker_testament()  {
   h="$1"
   shift
   if [[ -z $h ]]; then
      ls -1 $testaments			# no args: list hosts which have testament deposited
   else
      if [[ -z $1 ]]; then		# args: hostname void
         [[ -f $testaments/$h ]] &&	# host has testament?
         cat $testaments/$h		# yes: print testament
      else
         mkdir -p $testaments		# args: hostname commands
         echo "$@" >> $testaments/$h	# append commands to testament
      fi
   fi
}

testaments="$tmp/testaments"
type -t broker_$service > /dev/null &&
broker_$service $@
true
 