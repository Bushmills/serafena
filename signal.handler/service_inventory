# service broker multi-facette service handler: services inventory, provider, delegate
# inventory: build or selectively refresh service to host mapping database
# provider: who can respond to specified service requests
# delegate: forward a request to a machine able to respond

# @HELP signal @servicebroker inventory					# (re)build database of services on all hosts
# @HELP signal @servicebroker inventory <host1> <host2> ...		# add services of <host1|, <host2> ... to database
# @HELP signal @servicebroker delegate <service> <arguments>		# send request for <service> to a host which provides that service
# @HELP signal @servicebroker provider <service>			# list hosts providing <service>
# @HELP signal @servicebroker provider <service1> <service2> ...	# list hosts providing <service1>, <service2> ...
# @HELP signal @servicebroker connect <host>				# list hosts providing <service1>, <service2> ...
# @HELP signal @servicebroker disconnect <host>				# list hosts providing <service1>, <service2> ...


database="$tmp/servicebroker"
mkdir -p $database

broker_inventory()  {
   for host in ${@:-$(members all)}; do					# for each specified host (or @all, if void) ...
# @TODO - here is some potential to affect a wrong directory with deletion of files if host names are doctored accordingly,
      rm -f $database/*/$host						#    start by wiping info on host completely
# @TODO speedup potential: an additional service view, with just a horizontal list of active services, no extra info,
# @TODO can be used by touch in a single command. without a need to loop through the services.
      signal $host service state |
      while read state service host stamp _; do				#    then run through the list host reported as installed services
         ((state)) && {							#    only active services can be responded to
            mkdir -p $database/$service					#    host specific directory for tallying its services
            touch $database/$service/$host				#    mark service
         }
      done
   done
   rmdir --ignore-fail-on-non-empty $database/*
}

# @FACETTE provider
broker_provider()  {
   for service in $@; do						# for each specified host (or @all, if void) ...
      [[ -d $database/$service ]] && {
         cd $database/$service
         echo $(printf '%s\n' * | sort -R)
      } || echo
   done
}

# @FACETTE delegate
broker_delegate()  {
   service=$1
   shift
   cd $database/$service && {
      host=($(printf '%s\n' * | sort -R))
      signal $host $service $@
   }
}


# meant to receive information about connecting/disconnecting hosts from
# external sources, like hooks of vpn or dhcp servers.

# @TODO deal with case of multiple service brokers
# @FACETTE connect
broker_connect()  {
   host="$1"
   signal $host update && {		# more in updating we're interested whether the host replies. Only then will it be added to @all
      sl inventory $host		# update service database
      sa group all + $host		# ask everybody to add host to group @all
      signal $host welcome		# host may wish to give some introductory statements
   }
}

# @FACETTE disconnect
broker_disconnect()  {			# a disconnecting host gets removed in any case. Even if the host isn't known here at all,
# @TODO undo what host may have put in after it received the welcome.
#       host should possibly cooperate: telling another host (servicebroker?) how to undo its customisations.
#       it may not be able to do so itself (power, crash, misc failures)
   sa group all - $1			# attempt to remove a host which is not group memeber doesn't hurt
}

type -t broker_$service > /dev/null &&
broker_$service $@
true
 