# service broker multi-facette service handler: services inventory, provider, delegate
# inventory: build or selectively refresh service to host mapping database
# provider: who can respond to specified service requests
# delegate: forward a request to a machine able to respond

# @HELP signal @servicebroker inventory					# (re)build inventory of services on all hosts
# @HELP signal @servicebroker inventory <host1> <host2> ...		# add services of <host1|, <host2> ... to inventory
# @HELP signal @servicebroker delegate <service> <arguments>		# send request for <service> to a host which provides that service
# @HELP signal @servicebroker provider <service>			# list hosts providing <service>
# @HELP signal @servicebroker provider <service1> <service2> ...	# list hosts providing <service1>, <service2> ...
# @HELP signal @servicebroker connect <host>				# list hosts providing <service1>, <service2> ...
# @HELP signal @servicebroker disconnect <host>				# list hosts providing <service1>, <service2> ...


broker_inventory()  {
   for host in ${@:-$(members all)}; do					# for each specified host (or @all, if void) ...
# @TODO - here is some potential to affect a wrong directory with deletion of files if host names are doctored accordingly,
      rm -f $inventory/*/$host						#    start by wiping info on host completely
# @TODO speedup potential: an additional service view, with just a horizontal list of active services, no extra info,
# @TODO can be used by touch in a single command. without a need to loop through the services.
      signal $host service state |
      while read state service host stamp _; do				#    then run through the list host reported as installed services
         ((state)) && {							#    only active services can be responded to
            mkdir -p $inventory/$service					#    host specific directory for tallying its services
            touch $inventory/$service/$host				#    mark service
         }
      done
   done
   rmdir --ignore-fail-on-non-empty $inventory/*
}

# @FACETTE provider
broker_provider()  {
   for service in $@; do						# for each specified host (or @all, if void) ...
      [[ -d $inventory/$service ]] && {
         cd $inventory/$service
         printf '%s ' $(ls -1 | sort -R)
      }
      echo
   done
}

# @FACETTE delegate
broker_delegate()  {
   service=$1
   shift
   cd $inventory/$service && {
      host=($(ls -1 | sort -R))
      signal $host $service $@
   }
}


# meant to receive information about connecting/disconnecting hosts from
# external sources, like hooks of vpn or dhcp servers.
# @TODO deal with case of multiple service brokers
# @FACETTE connect
broker_connect()  {
#   host="$1"
   signal $1 update && {		# more in updating we're interested whether the host replies. Only then will it be added to @all
      sl inventory $1			# update service database
      sa group all + $1			# ask everybody to add host to group @all
      signal $1 welcome			# host may wish to give some introductory statements
   }
}


lost="$tmp/lost"

# @FACETTE disconnect
broker_disconnect()  {			# a disconnecting host gets removed in any case. Even if the host isn't known here at all,
# @TODO undo what host may have put in after it received the welcome. Busy with it now.
   sa group all - $1			# attempt to remove a host which is not group member doesn't hurt
   [[ -f $lost/$1 ]] && {
      source $lost/$1
      mv $lost/$1 $lost/$1.done
   }
}

# @FACETTE lost
broker_lost()  {
   host="$1"
   shift
   [[ -z $host ]] || {
      mkdir -p $lost
      echo "$@" > $lost/$host
   }
}

type -t broker_$service > /dev/null &&
broker_$service $@
true
 