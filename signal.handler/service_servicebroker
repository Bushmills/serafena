# know which host offers which service.
# inform hosts querying about providers of services who can.

# will be split into services provider, delegate and servicebroker.
# provider and delegate will query servicebroker.
# this need dynamic data storage facility on hosts (storing hostname of servicebroker)

# @HELP signal <host> servicebroker inventory					# (re)build database of services on all hosts
# @HELP signal <host> servicebroker inventory <host1> <host2> ...		# add services of <host1|, <host2> ... to database
# @HELP signal <host> servicebroker provider <service>			# list hosts providing <service>
# @HELP signal <host> servicebroker provider <service1> <service2> ... 	# list hosts providing <service1>, <service2> ...
# @HELP signal <host> servicebroker delegate <service> <arguments>		# send request for <service> to a host which provides that service

# consider to add replacements for service_delegate and service_provider on
# host servicebroker: that host doesn't need to find a servicebroker - it
# knows already that it is one itself. Replaced methods could reflect this.

database="$tmp/servicebroker"

cmd="$1"
shift

servicebroker_inventory()  {
   hosts=${@:-$all}
   mkdir -p $database
   for host in $hosts; do
      rm -f $database/*/$host
      signal $host service list |
      awk '$1 == "an" { print $3 }' |
      while read service; do
         mkdir -p $database/$service
         touch $database/$service/$host
      done
   done
   rmdir --ignore-fail-on-non-empty $database/*
}

servicebroker_provider()  {
   services="$@"
   for service in $services; do
      [[ -d $database/$service ]] && {
         cd $database/$service && printf '%s\n' * | sort -R
      } || echo
   done
}

servicebroker_delegate()  {
   service=$1
   shift
   cd $database/$service && {
      host=($(printf '%s\n' * | sort -R))
      signal $host $service $@
   }
}

type -t servicebroker_$cmd > /dev/null &&
servicebroker_$cmd $@
true
